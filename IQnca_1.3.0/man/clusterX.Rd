% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/general_auxiliaries.R
\name{clusterX}
\alias{clusterX}
\alias{statXY}
\title{Cluster Data in Blocks of Similar x Values and Summarize y Values per Block}
\usage{
clusterX(
  x,
  y = NULL,
  groupsize = 5,
  resolution = 0.1,
  lambda = 1,
  iterlim = 100,
  log = FALSE
)

statXY(x, y = NULL, ..., quantiles = c(0.05, 0.95))
}
\arguments{
\item{x}{x values or data.frame of x and y values}

\item{y}{y values or NULL, if x is a data.frame of x and y values}

\item{groupsize}{smallest expected group size}

\item{resolution}{gaps between groups of data points greater than \code{resolution}
lead to separation of groups.}

\item{lambda}{penalization of intra-group variance, set to 1 to have more groups
and set to 0 to get less but larger groups.}

\item{iterlim}{maximum number of iterations the algorithm takes.}

\item{log}{cluster on \code{log(x)} or on \code{x}. Does not change the value of  \code{resolution}.}

\item{...}{arguments going to \code{clusterX()}.}

\item{quantiles}{the requested quantiles, usually 0.05 and 0.95. Quantiles are returned in columns named \code{PX.VALUE},
where \code{X = round(100*quantiles)}.}
}
\value{
\code{clusterX()} returns a data.frame with x, y and group values. Group is returned as a factor with numerically sorted levels.

\code{statXY()} returns summary information as a data frame. The output of \code{clusterX()}
is returned in the attribute "clusterOut".
}
\description{
Cluster Data in Blocks of Similar x Values and Summarize y Values per Block
}
\details{
Data points are sorted by increasing x value and assigned into groups of size \code{groupsize}.
Next, groups separated by less than \code{resolution} are merged. In the following iterative algorithm,
the L1-distance of each data point to each of the groups is computed and wheighted by the groups geometric
standard deviation. Data points are then reassigned to the closest group. The procedure is repeated until
group membership does not change any more.

\code{statXY()} computes a data.frame with the following columns
\itemize{
\item \code{GROUP = group}, group identifier
\item \code{TIME = mean(x)}, mean group x value, usually time
\item \code{MEAN.VALUE = mean(y)}, mean group y value
\item \code{MEDIAN.VALUE = median(y)}, median of group y values
\item \code{SD.VALUE = sd(y)}, standard deviation of group y values
\item \code{SE.VALUE = sd(y)/sqrt(length(y))}, standard error of group y values
\item \code{GEOMMEAN.VALUE = exp(mean(log(y)))}, geometrical mean of y values
\item \code{GEOMSD.VALUE = exp(sd(log(y)))}, geometrical standard deviation of y values
\item \code{PX.VALUE = quantile(y, probs = X/100)}, X\\%-quantile of the group y values
}
}
\examples{
\dontrun{

library(ggplot2)

# Center timers for simulation and function to produce nice curve
timesD <- c(2, 10, 15, 30, 60, 120)
myfn <- function(x) 100*(1-exp(-.03*x))*exp(-.1*x)
# Randomly sampled times around center times with variable sample size
times <- unlist(lapply(timesD, function(x) stats::rnorm(runif(1, 2, 10), x, 0.2*x)))
# Simulate noisy data
x <- data.frame(
  TIME = times,
  VALUE = stats::rnorm(length(times), myfn(times), 0.1*myfn(times) + 1)
)
x <- subset(x, TIME > 0)

# Run cluster algorithm and get statistics
stat <- statXY(x, groupsize = 5, resolution = .01)
out <- attr(stat, "clusterOut")


# Plot result
P <- ggplot(out, aes(x = TIME, y = VALUE, color = block, pch = block)) + geom_point() +
  annotate("line", x = stat$TIME, y = stat$MEDIAN.VALUE) +
  annotate("line", x = stat$TIME, y = c(stat$P5.VALUE), lty = 2) +
  annotate("line", x = stat$TIME, y = c(stat$P95.VALUE), lty = 2)
print(P)
print(P + scale_x_log10())


}
}
